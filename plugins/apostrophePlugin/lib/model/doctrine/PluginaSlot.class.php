<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginaSlot extends BaseaSlot
{
  protected $editDefault = false;
  	
  // By default, the editor for a slot is accessed by double-clicking
  // on an outlined normal view of the slot. That's not appropriate
  // for some custom slot types. Say so by overriding this function
  // in your slot's model subclass and returning false. Then you'll
  // need to implement opening the editor yourself. You can do that
  // in your _normal_view.php by testing $editable and outputting
  // button_to("Edit", $showEditorJS) or similar if it is true.
  // showEditorJS contains ready-to-go jQuery code to hide the
  // normal view and display the editor view.
  //
  // The return value of this method becomes the default setting of
  // the outline_editable option, which can still be overridden
  // manually.

  public function isOutlineEditable()
  {
    return true;
  }

  // You should return a reasonable plaintext representation of your
  // slot's contents for search indexing purposes. A media slot
  // would return the title and description of its contents.

  public function getSearchText()
  {
    return '';
  }

  /**
   * This function returns a plaintext representation of your slot's contents.
   * This differs from getSearchText in that it should only be used for slots
   * with user entered text.
   * @return string
   */
  public function getText()
  {
    return '';
  }

  // Conveniences for slots that use $this->value to store all of their state
  // and wish to store an array there.
  
  public function getArrayValue($default = array())
  {
    if (strlen($this->value))
    {
      return unserialize($this->value);
    }
    return $default;
  }
 
  public function setArrayValue($value)
  {
    if (!is_array($value))
    {
      throw new Exception("Argument is not an array in setArrayValue");
    }
    $this->value = serialize($value);
  }
  
  // Called on the current version of every slot by the a:refresh-slots task, 
  // a periodic task used to update cached information that may be part of each slot's state 
  // and which is subject to occasional change. Right now the best example is the use of 
  // static URLs pointing directly to the media server for performance in
  // media slots. These need refreshing if the frontend controller name changes
  // as part of launch. Also media slots will clean up and remove references to
  // deleted media items when refresh is called. 
  
  public function refreshSlot()
  {
  }
  
  public function editDefault()
  {
    return $this->editDefault;  
  }
  
  public function setEditDefault($editDefault)
  {
    $this->editDefault = $editDefault;
  }
  
  public function isOpen()
  {
    return $this->isNew() && $this->editDefault;
  }
  
  // You must pass the slot options in effect so that allowed_variants can be taken into account
  public function getEffectiveVariant($options)
  {
    $variants = aTools::getVariantsForSlotType($this->type, $options);
    if (!isset($variants))
    {
      // No variants, no class
      return '';
    }
    // Treat null and an empty string the same
    $variant = $this->variant . '';
    // If the variant is not defined (and the empty string will not be),
    // and there is at least one variant, return the first one as the default.
    // If there are no variants return an empty string
    if (!isset($variants[$variant]))
    {
      if (count($variants))
      {
        // Return the first variant for the type, if any, when the variant is bogus
        $keys = array_keys($variants);
        return $keys[0];
      }
      return '';
    }
    // If the variant is valid, return it as the CSS class
    return $this->variant;
  }
  
  // We don't want to copy most of the references, but we do need
  // copies of the refClass objects for associated media. Otherwise
  // there is no meaningful version control for media slots. We can
  // create the copies implicitly by building up a new MediaItems list.
  
  public function copy($deep = false)
  {
    // We ignore the deep parameter (it's part of the signature of the method in
    // the base class), instead copying what is appropriate (links to media items) and not
    // things that are not our responsibility (actual media items)
    
    $new = parent::copy();
    // This could perhaps be a little faster - right now we're pulling in the
    // actual MediaItem objects, all we really need is their IDs. That's one join
    // more than strictly necessary
    $mediaItems = $this->MediaItems;
    $ids = array();
    foreach ($mediaItems as $mediaItem)
    {
      $ids[] = $mediaItem->id;
    }
    $new->link('MediaItems', $ids);
    return $new;
  }
  
  // Doctrine_Collection::contains doesn't really take a primary key as an argument as
  // you'd expect. Fortunately getPrimaryKeys is available
  
  public function containsMediaItemId($id)
  {
    $idMap = array_flip($this->MediaItems->getPrimaryKeys());
    return isset($idMap[$id]);
  }
}
