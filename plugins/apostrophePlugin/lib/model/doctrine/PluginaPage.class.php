<?php

/**
 * This class has been auto-generated by the Doctrine ORM Framework
 */
abstract class PluginaPage extends BaseaPage
{
  const NEXT_PERMID = -1;
  public $culture;
  
  // Keep all cached information here for easy reference and inclusion 
  // in the reset code in hydrate()
  public $privilegesCache = null;
  private $slotCache = false;
  private $childrenCache = null;
  private $childrenCacheLivingOnly = null;
  private $childrenCacheSlot = null;
  private $ancestorsCache = false;
  private $parentCache = false;

  public function hydrate(array $data, $overwriteLocalChanges = true)
  {
    // Purge all caches when Doctrine refreshes the object
    $this->slotCache = false;
    $this->privilegesCache = array();
    $this->childrenCache = null;
    $this->childrenCacheLivingOnly = null;
    $this->childrenCacheSlot = null;
    $this->ancestorsCache = false;
    $this->parentCache = false;
    $this->ancestorsInfo = null;
    $this->peerInfo = null;
    $this->childrenInfo = null;
    $this->tabsInfo = null;
    return parent::hydrate($data, $overwriteLocalChanges);
  }

  // Not a typo. Doctrine calls construct() for you as an alternative
  // to __construct(), which it won't let you override.
  public function construct()
  {
    $this->culture = aTools::getUserCulture();
    $this->privilegesCache = array();
  }
  private function log($message)
  {
    sfContext::getInstance()->getLogger()->info("PAGE: $message");
  }

  public function userHasPrivilege($privilege, $user = false)
  {
    return aPageTable::checkPrivilege($privilege, $this, $user);
  }

  // The new API:
  //
  // getArea(name)
  // newAreaVersion(name, action, params)
 

  private function populateSlotCache()
  {
    if ($this->slotCache === false)
    {
      $this->slotCache = array();
      // We have $this->Areas courtesy of whatever query
      // fetched the page in the first place
      foreach ($this->Areas as $area)
      {
        $areaVersion = $area->AreaVersions[0];
        foreach ($areaVersion->AreaVersionSlots as $areaVersionSlot)
        {
          $slot = $areaVersionSlot->Slot;
          $this->slotCache[$this->culture][$area->name][$areaVersionSlot->permid] = $slot;
          // foreach ($slot->MediaItems as $mediaItem)
          // {
          //   echo($mediaItem->id . ',');
          // }
        }
      }
    }
  }
  
  // WARNING: You need to retrieve the slots properly before you can use this
  // reliably. That means using aPageTable::retrieveBySlugWithSlots() or
  // aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
  // the page in the first place.
  
  // Otherwise Doctrine will pull every slot by default, including old slots
  // in the history and slots in other languages, and they will not be in
  // the right order, especially if your client is in your office for a dmeo.
  // So heed this warning. Thanks.
  
  public function hasSlot($name, $permid = 1)
  {
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture][$name][$permid]))
    {
      return true;
    }
    return false;
  }
  public function getSlot($name, $permid = 1)
  {
    if ($this->hasSlot($name, $permid))
    {
      return $this->slotCache[$this->culture][$name][$permid];
    }
    return false;
  }
  
  // WARNING: You need to retrieve the slots properly before you can use this
  // reliably. That means using aPageTable::retrieveBySlugWithSlots() or
  // aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
  // the page in the first place.
  
  // Otherwise Doctrine will pull every slot by default, including old slots
  // in the history and slots in other languages, and they will not be in
  // the right order, especially if your client is in your office for a dmeo.
  // So heed this warning. Thanks.
  
  // $new can be a slot class name, an already-created slot object, or false.
  // If it is false no new slot is added to the list to be returned.
  // If it is a class name the slot is constructed for you. 
  //
  // If $newFirst is true the new slot will be at the top of the area,
  // otherwise the bottom.
  public function getArea($name, $new = false, $newFirst = false)
  {
    $this->populateSlotCache();
    $results = array();
    if ($new)
    {
      $permidAndRank = $this->getNextPermidAndRank($name, $newFirst);
      if (!($new instanceof aSlot))
      {
        // It's a type name, make one
        $new = $this->createSlot($new);
      }
      else
      {
        // We passed one in
      }
    }
    if ($new && $newFirst)
    {
      $results[$permidAndRank['permid']] = $new;
    }
    if (isset($this->slotCache[$this->culture][$name]))
    {
      foreach ($this->slotCache[$this->culture][$name] as $permid => $slot)
      {
        $results[$permid] = $slot;
      }
    }
    if ($new && (!$newFirst))
    {
      $results[$permidAndRank['permid']] = $new;
    }
    return $results;
  }

  public function getNextPermidAndRank($name, $first = false)
  {
    $query = Doctrine_Query::create()->
        select('max(s.permid) as m, ' 
          . ($first ? 'min' : 'max') . '(s.rank) as r')->
        from('aArea a')->
        leftJoin('a.AreaVersions v')->
        leftJoin('v.AreaVersionSlots s')->
        where('a.name = ? AND a.page_id = ?', array($name, $this->id));
    $result = $query->execute();
         
    if (isset($result[0]['m']))
    {
      $permid = $result[0]['m'] + 1;
    }
    else
    {
      $permid = 1;
    }
    // Negative ranks = perfectly fine and useful for
    // implementing "new slots on top"
    if (isset($result[0]['r']))
    {
      if ($first)
      {
        $rank = $result[0]['r'] - 1;
      }
      else
      {
        $rank = $result[0]['r'] + 1;
      }
    }
    else
    {
      $rank = 1;
    }
    return array(
      'permid' => $permid, 
      'rank' => $rank);
  }

  public function createSlot($type)
  {
    $class = $type . "Slot";
    $slot = new $class;
    $slot->type = $type;
    return $slot;
  }

  // WARNING: You need to retrieve the slots properly before you can use this
  // reliably. That means using aPageTable::retrieveBySlugWithSlots() or
  // aPageTable::retrieveByIdWithSlots() or aPageTable::queryWithSlots() to retrieve
  // the page in the first place. (You can also use aPageTable::retrieveBySlugWithTitles()
  // to avoid loading other slots on the page, but only if you don't turn around and try
  // to use those other slots.)
  
  // Otherwise Doctrine will pull every slot by default, including old slots
  // in the history and slots in other languages, and they will not be in
  // the right order, especially if your client is in your office for a dmeo.
  // So heed this warning. Thanks.

  public function getTitle()
  {
    $titleSlot = $this->getSlot('title');
    if ($titleSlot)
    {
      $result = $titleSlot->value;
    }
    else
    {
      $result = '';
    }
    $title = trim($result);
    if (!strlen($result))
    {
      // Don't break the UI, return something reasonable
      $slug = $this->slug;
      $title = substr(strrchr($slug, "/"), 1);
      if (!strlen($title))
      {
        $title = "Home";
      }
    }
    return $title;
  }
  
  public function getAreaVersions($name, $selectOptions = true, $limit = 10)
  {
    $q = Doctrine_Query::create()->
      from("aAreaVersion av")->
      leftJoin("av.Area a")->
      leftJoin("av.Author au")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      orderBy("av.version desc");
    if(!is_null($limit))
      $q->limit($limit);
    $areaVersions = $q->execute();
    $versions = array();  
    foreach ($areaVersions as $areaVersion)
    {
      if ($selectOptions)
      {
        $versions[$areaVersion->version] = 
          $areaVersion->created_at . " " . ($areaVersion->Author ? 
              $areaVersion->Author->username : "NONE") . " " . $areaVersion->diff;
      }
      else
      {
        $versions[$areaVersion->version] =
          array("created_at" => $areaVersion->created_at, "author" => $areaVersion->Author ? $areaVersion->Author->username : "NONE", "diff" => $areaVersion->diff,
          "version" => $areaVersion['version']);
      }
    }
    return $versions;   
  }

  public function getAreaCurrentVersion($name)
  {
    $area = Doctrine_Query::create()->
      from("aArea a")->
      where("a.page_id = ? AND a.name = ? AND a.culture = ?",
        array($this->id, $name, $this->culture))->
      fetchOne();
    if ($area)
    {
      return $area->latest_version;
    }
    return 0;
  }

  // This is not the most efficient way to learn about the child pages of the current page.
  // See getChildrenInfo. This method is now primarily for backwards compatibility and relatively rare cases where 
  // you need a slot other than the title.
    
  // Returns an array even when there are zero children.
  // Who in the world wants to special case that as if it
  // were the end of the world?
  public function getChildren($livingOnly = true, $withSlot = 'title')
  {
    if ($this->childrenCache !== null)
    {
      if (($livingOnly === $this->childrenCacheLivingOnly) && ($this->childrenCacheSlot === $withSlot))
      {
        return $this->childrenCache;
      }
    }
    // TODO: consider whether it's possible to get the base query to
    // exclude archived children. That would result in multiple
    // calls to where(), but perhaps Doctrine can combine them for us.
    if ($withSlot !== false)
    {
      aPageTable::treeSlotOn($withSlot);      
    }
    $children = $this->getNode()->getChildren();
    
    if ($children === false)
    {
      $children = array();
    }
    
    if ($withSlot !== false)
    {
      aPageTable::treeSlotOff();
    }
    
    // Don't let Doctrine's clever reuse of objects prevent us from seeing
    // the results if we fetch a different slot this time... unless the child
    // is also the current page. In that case we assume that we have superior
    // data in the cache already (inclusive of all slots). Discarding that
    // was leading to disappearing data on emap
      
    $current = aTools::getCurrentPage();
    foreach ($children as $child)
    {
      if ($current && ($current->id === $child->id))
      {
        continue;
      }
      $child->clearSlotCache();
    }
    if ($children !== false)
    {
      $living = array();
      $dead = array();
      foreach ($children as $child)
      {
        if ($child->admin)
        {
          // Never show admin pages in navigation
          continue;
        }
        if ($child->archived)
        {
          $dead[] = $child;
        }
        else
        {
          $living[] = $child;
        }
      }
      if ($livingOnly)
      {
        $children = $living;
      }
      else
      {
        $children = array_merge($living, $dead);
      }
    }
    else
    {
      $children = array();
    }
    $this->childrenCache = $children;
    $this->childrenCacheLivingOnly = $livingOnly;
    $this->childrenCacheSlot = $withSlot;
    return $children;
  }

  // Optimized methods returning information about related pages.
  
  // All of these methods return an array of associative arrays, as follows:
  
  // array(
  //   array('id' => page1id, 'title' => page1title, 'slug' => page1slug, 'view_is_secure' => bool, 'archived' => bool, 'level' => level),
  //   array('id' => page2id, 'title' => page2title, 'slug' => page2slug, 'view_is_secure' => bool, 'archived' => bool, 'level' => level) ...
  // )
  
  // The getTreeInfo and getAccordionInfo methods return nested arrays. If a page has children that
  // are suitable to return, then the associative array for that page will have a 'children' key, and
  // the value will be an array of child pages, which may have children of their own. If a page has
  // no children there will not be a 'children' key (you may test isset($info['children'])).
  
  // To generate a URL for a page use: aTools::urlForPage($info['slug'])
  
  protected $ancestorsInfo;

  // Careful, the cache must hold the entire path including the item itself, we lop off the last element
	// before returning in those cases where it is not wanted.
  public function getAncestorsInfo($includeSelf = false)
  {
    if (!isset($this->ancestorsInfo))
    {
      $id = $this->id;
      // Since our presence on an admin page implies we know about it, it's OK to include
      // admin pages in the breadcrumb. It's not OK in other navigation
      $this->ancestorsInfo = $this->getPagesInfo(false, "( p.lft <= " . $this->lft . " AND p.rgt >= " . $this->rgt . ' )', true);
    }
		$ancestorsInfo = $this->ancestorsInfo;
		if (!$includeSelf)
		{
			$ancestorsInfo = $this->ancestorsInfo;
			array_pop($ancestorsInfo);
		}
		return $ancestorsInfo;
  }

  public function getParentInfo()
  {
    $info = $this->getAncestorsInfo();
    if (count($info))
    {
      return $info[count($info) - 1];
    }
    return false;
  }

  protected $peerInfo;
  
  public function getPeerInfo($livingOnly = true)
  {
    if (!isset($this->peersInfo))
    {
      $parentInfo = $this->getParentInfo();
      if (!$parentInfo)
      {
        // It's the home page. Return a stub: the home page is its only peer
        $this->peerInfo = array($this->getInfo());
      }
      else
      {
        $lft = $parentInfo['lft'];
        $rgt = $parentInfo['rgt'];
        $level = $parentInfo['level'] + 1;
        $this->peerInfo = $this->getPagesInfo($livingOnly, '(( p.lft > ' . $lft . ' AND p.rgt < ' . $rgt . ' ) AND (level = ' . $level . '))');        
      }       
    }   
    return $this->peerInfo;
  }

  // Sometimes it is useful to have an info structure describing a page object
  // (the aNavigation classes exploit this, so does the search index, which needs
  // to be able to determine privileges for a page with a minimum of overhead)
  
  public function getInfo()
  {
    return array('id' => $this->id, 'title' => $this->getTitle(), 'slug' => $this->slug, 'view_is_secure' => $this->view_is_secure, 'archived' => $this->archived, 'admin' => $this->admin, 'level' => $this->level, 'lft' => $this->lft, 'rgt' => $this->rgt);
  }
  
  protected $childrenInfo;
  
  public function getChildrenInfo($livingOnly = true)
  {
    if (!isset($this->childrenInfo))
    {
      $lft = $this->lft;
      $rgt = $this->rgt;
      $level = $this->level + 1;
      $this->childrenInfo = $this->getPagesInfo($livingOnly, '(( p.lft > ' . $lft . ' AND p.rgt < ' . $rgt . ' ) AND (level = ' . $level . '))');
    }
    return $this->childrenInfo;
  }

  protected $tabsInfo;
  
  public function getTabsInfo($livingOnly = true)
  {
    if (!isset($this->tabsInfo))
    {
      $id = $this->id;
      $this->tabsInfo = $this->getPagesInfo($livingOnly, '(level = 1)');
    }
    return $this->tabsInfo;
  }
  
  // If $depth is null we get all of the descendants
  public function getTreeInfo($livingOnly = true, $depth = null)
  {
    // Recursively builds a page tree. If a page has children, the info array for that
    // page will have a 'children' element containing an array of info arrays for its
    // children, etc.
    
    // Efficiently fetches only to the appropriate depth

    // Sometimes trees will have enabled children of disabled parents. When
    // we don't want disabled pages, we have to exclude those pages too, so we'll
    // do the exclusion at a higher level, not in the SQL query

    $infos = $this->getDescendantsInfo(false, $depth);
    $offset = 0;
    $level = 0;
    return $this->getTreeInfoBody($this->lft, $this->rgt, $infos, $offset, $level + 1, $depth, $livingOnly);
  }
  
  protected function getTreeInfoBody($lft, $rgt, $infos, &$offset, $level, $depth, $livingOnly)
  {
    $count = count($infos);
    $result = array();
    if ($depth === 0)
    {
      // Limit depth 
      return $result;
    }
    while ($offset < $count)
    {      
      $info = $infos[$offset];
      if (($info['lft'] <= $lft) || ($info['rgt'] >= $rgt))
      {
        break;
      }
      $offset++;
      $children = $this->getTreeInfoBody($info['lft'], $info['rgt'], $infos, $offset, $level + 1, isset($depth) ? ($depth - 1) : null, $livingOnly);
      if (count($children))
      {
        $info['children'] = $children;
      }
      if ($livingOnly && isset($info['archived']) && $info['archived'])
      {
        continue;
      }
      else
      {
        $result[] = $info;
      }
    }
    return $result;
  }
  
  
  // Accordion nav 
  // Always starts with the children of the root and comes down to the level of this page's children,
  // listing peers of this page's ancestors at every level. That is:
  
  // Home
  //   One
  //     1a
  //     1b
  //       1bx  <-- the current page
  //         1bxA
  //         ibxB
  //     1c
  //   Two
  
  // You can now specify the root slug, which defaults to the home page.
  
  // Note that children of Two, 1a, and 1c are NOT returned. Only the siblings of
  // the current page's ancestors, the current page and its siblings, and the immediate
  // children of the current page are returned. For a full tree use getTreeInfo().
  
  public function getAccordionInfo($livingOnly = true, $depth = null, $root = '/')
  {
    // As far as I can tell there is no super-elegant, single-query way to do this
    // without fetching a lot of extra pages. So do a peer fetch at each level.
    
    // First build an array of arrays listing the peers at each level

    // If you have enabled children of archived ancestors and you don't
    // want the ancestors to show up, you probably shouldn't be using
    // an accordion contro. in the first place
    $ancestors = $this->getAncestorsInfo();
    
    // Dump ancestors we don't care about
    for ($i = 0; ($i < count($ancestors)); $i++)
    {
      if ($ancestors[$i]['slug'] === $root)
      {
        $ancestors = array_slice($ancestors, $i);
        break;
      }
    }
    if ($i === count($ancestors))
    {
      throw new sfException("Root slug $root never found among ancestors in getAccordionInfo");
    }
    $result = array();
    // Ancestor levels
    foreach ($ancestors as $ancestor)
    {
      $lineage[] = $ancestor['id'];
      if ($ancestor['level'] == 0)
      {
        $result[] = array($ancestor);
      }
      else
      {
        // TODO: this is inefficient, come up with a way to call getPeerInfo for an
        // alternate ID without fetching that entire page
        $result[] = aPageTable::retrieveBySlug($ancestor['slug'])->getPeerInfo($livingOnly);
      }
    }
    // Current page peers level
    $result[] = $this->getPeerInfo($livingOnly);
    $lineage[] = $this->id;
    // Current page children level
    $result[] = $this->getChildrenInfo($livingOnly);
    
    // Now fix it up to be a properly nested array like that
    // returned by getTreeInfo(). On each pass take a reference
    // to the child that will own the children of the next pass
    $accordion = $result[0][0];
    $current = &$accordion;
    for ($i = 0; ($i < (count($result) - 1)); $i++)
    {
      $current['children'] = $result[$i + 1];
      if ($i + 1 < count($lineage))
      {
        // We've already started returning the kids as a flat array so 
        // we need to scan for it unfortunately. This entire method could
        // use more attention to performance
        foreach ($current['children'] as &$child)
        {
          if ($child['id'] == $lineage[$i + 1])
          {
            $current = &$child;
            break;
          }
        }
      }
    }
    
    // Don't return the home page itself, start with the tabs.
    // This is consistent with getTreeInfo() which should simplify implementations.
    // It's easy to add the home page in at a higher level if desired.
    return $accordion['children'];
  }

  // Used by the reorganize feature. Return value is compatible with jstree. 
  // See getTreeInfo for something more appropriate for front end navigation
  
  public function getTreeJSONReady($livingOnly = true)
  {
    // Recursively builds a page tree ready to be JSON-encoded and sent to
    // the jsTree object (yes this is rather specific to jsTree for the model layer,
    // but this would be a reasonable input format for any JS tree implementation).
    
    // Sometimes trees will have enabled children of archived parents. When
    // we don't want disabled pages, we have to exclude those pages too, so we'll
    // do the exclusion at a higher level, not in the SQL query
    $infos = $this->getDescendantsInfo(false);
    $offset = 0;
    $level = 0;
    $tree = array("attributes" => array("id" => "tree-" . $this->id),
      "data" => $this->getTitle(),
      "state" => 'open',
      "children" => $this->getTreeJSONReadyBody($this->lft, $this->rgt, $infos, $offset, $level + 1, $livingOnly)
    );
    if (!count($tree['children']))
    {
      unset($tree['children']);
    }
    else
    {
      $item['state'] = 'open';
    }
  return $tree;
  }

  protected function getTreeJSONReadyBody($lft, $rgt, $infos, &$offset, $level, $livingOnly)
  {
    $count = count($infos);
    $result = array();
    while ($offset < $count)
    {      
      $info = $infos[$offset];
      if (($info['lft'] <= $lft) || ($info['rgt'] >= $rgt))
      {
        break;
      }
      $offset++;
      $class = ($info['archived'])? 'archived' : 'alive';
      $class.= (!is_null($info['engine']))? ' engine-'.$info['engine'] : '';
      $item = array(
        "attributes" => array("id" => "tree-" . $info['id'], "class" => $class), 
        "data" => $info['title'],
        "children" => $this->getTreeJSONReadyBody($info['lft'], $info['rgt'], $infos, $offset, $level + 1, $livingOnly)
      );
      if (!count($item['children']))
      {
        unset($item['children']);
      }
      else
      {
        $item['state'] = ($level < 2) ? "open" : "closed";
      }
      if ($livingOnly && isset($info['archived']) && $info['archived'])
      {
        // Skip it (and therefore its children as well) in the final result
      }
      else
      {
        $result[] = $item;
      }
    }
    return $result;
  }
  
  // Low level access to all info for all descendants. You probably don't want this. For an interface that
  // gives you back a hierarchy see getTreeInfo. 
  protected function getDescendantsInfo($livingOnly = true, $depth = null)
  {
    $where = '( p.lft > ' . $this->lft . ' AND p.rgt < ' . $this->rgt . ' )';
    if (isset($depth))
    {
      $where = '(' . $where . ' AND (p.level <= ' . ($this->level + $depth) . '))';
    }
    return $this->getPagesInfo($livingOnly, $where);
  }
  
  // This is the low level query method used to implement the above. You won't call this directly
  // unless you're implementing a new type of query for related pages
  
  protected function getPagesInfo($livingOnly = true, $where, $admin = false)
  {
    // Raw PDO for performance
    $connection = Doctrine_Manager::connection();
    $pdo = $connection->getDbh();
    // When we look for the current culture, we need to do it in the ON clause, not
    // in the WHERE clause. Otherwise we don't get any information at all about pages
    // not i18n'd yet
    $escCulture = $connection->quote($this->getCulture());
    $query = "SELECT p.id, p.slug, p.view_is_secure, p.archived, p.lft, p.rgt, p.level, p.engine, p.template, s.value AS title FROM a_page p
      LEFT JOIN a_area a ON a.page_id = p.id AND a.name = 'title' AND a.culture = $escCulture
      LEFT JOIN a_area_version v ON v.area_id = a.id AND a.latest_version = v.version 
      LEFT JOIN a_area_version_slot avs ON avs.area_version_id = v.id
      LEFT JOIN a_slot s ON s.id = avs.slot_id ";
    $whereClauses = array();
    if ($livingOnly)
    {
      // Watch out, p.archived IS NULL in some older dbs
      
      // = FALSE is not SQL92 correct. IS FALSE is. And so it works in SQLite. Learn something
      // new every day. 
      $whereClauses[] = '(p.archived IS FALSE OR p.archived IS NULL)';
    }
    // admin pages are almost never visible in navigation
    if (!$admin)
    {
      $whereClauses[] = '(p.admin IS FALSE OR p.admin IS NULL)';
    }
    $whereClauses[] = $where;
    $query .= "WHERE " . implode(' AND ', $whereClauses);
    $query .= " ORDER BY p.lft";
    $resultSet = $pdo->query($query);
    // Turn it into an actual array (what would happen if we didn't bother?)
    $results = array();
    foreach ($resultSet as $result)
    {
      // If there is no title yet, supply one to help the translator limp along
      if (!strlen($result['title']))
      {
        if ($result['slug'] === '/')
        {
          $result['title'] = 'home';
        }
        else
        {
          if (preg_match('|([^/]+)$|', $result['slug'], $matches))
          {
            $result['title'] = $matches[1];
          }
        }
      }
      $results[] = $result;
    }
    return $results;
  }
 
  public function hasChildren($livingOnly = true)
  {
    // not as inefficient as it looks because of the caching feature
    return (count($this->getChildren($livingOnly)) != 0);
  }

  public function getUrl($absolute = true)
  {
    return aTools::urlForPage($this->getSlug(), $absolute);
  }

  public function getAncestors()
  {
    // Home page has no ancestors; save a query on a popular page
    if ($this->level == 0)
    {
      return array();
    }
    if ($this->ancestorsCache !== false)
    {
      return $this->ancestorsCache;
    } 
    aPageTable::treeTitlesOn();
    $this->ancestorsCache = $this->getNode()->getAncestors();
    aPageTable::treeTitlesOff();
    if ($this->ancestorsCache === false)
    {
      // Empty lists are not evil!
      $this->ancestorsCache = array();
    }
    return $this->ancestorsCache;
  }
  public function isEqualTo($page)
  {
    return ($page->getSlug() === $this->getSlug());
  }

  public function begin()
  {
    $conn = Doctrine_Manager::connection();
    $conn->beginTransaction();
  }

  public function end()
  {
    $conn = Doctrine_Manager::connection();
    $conn->commit();
  }

  // SAVE ANY CHANGES to the actual page object FIRST before you call this method.

  // 20090505: you must pass valid HTML text (i.e. pre-escaped entities)
  public function setTitle($title)
  {
    $slot = $this->createSlot('aText');
    $slot->value = $title;
    $slot->save();
    $this->newAreaVersion('title', 'update', 
      array(
        'permid' => 1, 
        'slot' => $slot));
  }

  // SAVE ANY CHANGES to the actual page object FIRST before you call this method.
  
  public function newAreaVersion($name, $action, $params = false)
  {
    $diff = '';
    if ($params === false)
    {
      $params = array();
    }
    $this->begin();
    // We use the slots already queried as a basis for the new version,
    // because that makes rollback easy to implement etc. But we
    // MUST fetch the latest copy of the area object to make sure
    // we don't create duplicate versions.

    // When we're adding a new slot to an area we need to make sure it
    // it is first in the hash so it gets ranked first
    if ($action === 'add')
    {
      // New: support for specifying whether the new slot is at top or bottom of the area
      $top = (!isset($params['top'])) || $params['top'];
      $diff = '<strong>' . aString::limitCharacters($params['slot']->getSearchText(), 20) . "</strong>";
      $newSlots = $this->getArea($name, $params['slot'], $top);
    }
    else
    {
      $newSlots = $this->getArea($name);
    }
    $area = aAreaTable::retrieveOrCreateByPageIdAndName(
      $this->id,
      $name);
    if (!$area->id)
    {
      // We need an ID established
      $area->save();
    }
    $areaVersion = new aAreaVersion();
    $areaVersion->area_id = $area->id;
    $areaVersion->version = $area->latest_version + 1;
    // Don't crash on an anon edit, such as an edit made by a task
    if (sfContext::hasInstance() && sfContext::getInstance()->getUser()->getGuardUser())
    {
      $areaVersion->author_id = 
        sfContext::getInstance()->getUser()->getGuardUser()->getId();
    }
    if ($action === 'delete')
    {
      if (isset($newSlots[$params['permid']]))
      {
        $diff = '<strike>' . aString::limitCharacters($newSlots[$params['permid']]->getSearchText(), 20) . '</strike>';
        unset($newSlots[$params['permid']]);
      }
    }
    elseif ($action === 'update')
    {
      $oldText = '';
      if (isset($newSlots[$params['permid']]))
      {
        $oldText = $newSlots[$params['permid']]->getSearchText(); 
      }
      $newText = $params['slot']->getSearchText();
      $fullDiff = aString::diff($oldText, $newText);
      $diff = '';
      if (!empty($fullDiff['onlyin1']))
      {
        $diff .= '<strike>' . aString::limitCharacters($fullDiff['onlyin1'][0], 20) . '</strike>';
      }
      if (!empty($fullDiff['onlyin2']))
      {
        $diff .= '<strong>' . aString::limitCharacters($fullDiff['onlyin2'][0], 20) . '</strong>';
      }
      $newSlots[$params['permid']] = $params['slot']; 
    }
    elseif ($action === 'variant')
    {
      $newSlot = $newSlots[$params['permid']]->copy();
      if (!$newSlot)
      {
        throw new sfException('Slot does not exist');
      }
      $variants = sfConfig::get('app_a_slot_variants');
      if (!isset($variants[$newSlot->type][$params['variant']]))
      {
        throw new sfException('Variant not defined for this slot type');
      }
      $newSlot->variant = $params['variant'];
      // Must have an id before we can make an AreaVersionSlot referencing it
      $newSlot->save();
      $newSlots[$params['permid']] = $newSlot;
      $diff = $newSlot->variant;
    }
    elseif ($action === 'add')
    {
      // We took care of this in the getArea call
    }
    elseif ($action === 'sort')
    {
      $diff = '[Reordered slots]';
      $newerSlots = array();
      foreach ($params['permids'] as $permid)
      {
        $newerSlots[$permid] = $newSlots[$permid];
      }
      $newSlots = $newerSlots;
    }
    elseif ($action === 'revert')
    {
      // TODO: actually represent the changes carried out by the reversion
      // in the diff. That's rather expensive because many slots in the area
      // may have changed all at once.
      $diff = '[Reverted to older version]';
      # We just want whatever is in the slot cache copied to a new version
    }
    
    $areaVersion->diff = $diff;
    $areaVersion->save();

    $rank = 1;
    foreach ($newSlots as $permid => $slot)
    {
      // After unset, foreach shows keys but has null values
      if (!$slot)
      {
        continue;
      }
      $areaVersionSlot = new aAreaVersionSlot();
      $areaVersionSlot->slot_id = $slot->id;
      $areaVersionSlot->permid = $permid;
      $areaVersionSlot->area_version_id = $areaVersion->id;
      $areaVersionSlot->rank = $rank++;
      $areaVersionSlot->save();
    }
    $area->latest_version++;
    $area->save();
    $this->requestSearchUpdate();
    $this->end();
  }
  
  public function requestSearchUpdate()
  {
    if (sfConfig::get('app_a_defer_search_updates', false))
    {
      // Deferred updates are sometimes nice for performance...
      aLuceneUpdateTable::requestUpdate($this);
    }
    else
    {
      // ... But the average developer hates cron.
      // Without this the changes we just made aren't visible to getSearchText,
      // we need to trigger a thorough recaching
      aPageTable::retrieveByIdWithSlots($this->id);
      $this->updateLuceneIndex();
    }
  }
  
  public function clearSlotCache()
  {
    $this->slotCache = false;
  }
  public function getAccessesById($privilege)
  {
    $candidateGroup = sfConfig::get('app_a_' . $privilege . '_candidate_group', false);
    $sufficientGroup = sfConfig::get('app_a_' . $privilege . '_sufficient_group', false);
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $withClauses = array();
    $withParameters = array();
    if ($candidateGroup)
    {
      $candidateGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($candidateGroup);
      if (!$candidateGroup)
      {
        throw new Exception("Candidate group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $candidateGroup->id;
    }
    if ($sufficientGroup)
    {
      $sufficientGroup = Doctrine::getTable('sfGuardGroup')->findOneByName($sufficientGroup);
      if (!$sufficientGroup)
      {
        throw new Exception("Sufficient group for $privilege was set but does not exist");
      }
      $withClauses[] = "g.id = ?";
      $withParameters[] = $sufficientGroup->id;
    }
    if (count($withClauses))
    {
      $query->innerJoin("u.groups g with " . implode(" OR ", $withClauses),
        $withParameters);
    } 
    $query->orderBy("u.username asc");
    $allResults = $query->execute();
    $all = array();
    $sufficient = array();
    foreach ($allResults as $actor)
    {
      $all[$actor->id] = $actor->username;
      if ($sufficientGroup && ($actor->hasGroup($sufficientGroup->getName())))
      {
        $sufficient[] = $actor->id;
      }
    }
    $query = Doctrine_Query::create();
    $query->from("sfGuardUser u");
    $ancestors = $this->getAncestors();
    $ancestorIds = array();
    foreach ($ancestors as $ancestor)
    {
      $ancestorIds[] = $ancestor->id;
    }
    $ancestorIds[] = $this->id;
    $query->innerJoin("u.Accesses a with a.page_id IN (" .
      implode(",", $ancestorIds) . ") and a.privilege = ?", 
      array($privilege));
    $query->orderBy("u.username asc");
    $selectedResults = $query->execute();
    $selected = array();
    $inherited = array();
    $found = array();
    foreach ($selectedResults as $user)
    {
      foreach ($user->Accesses as $access)
      {
        if (!isset($found[$user->id]))
        {
          if ($access->page_id !== $this->id)
          {
            $inherited[] = $user->id;
            $found[$user->id] = true;
          }
          else
          {
            $selected[] = $user->id;
            $found[$user->id] = true;
          }
        }
      }
    }
    return array($all, $selected, $inherited, $sufficient);
  }
  public function setAccessesById($privilege, $ids)
  {
    // Could probably be more elegant using Doctrine collections
    $query = Doctrine_Query::create();
    // Make sure we select() only a.* so that we don't wind up
    // reloading the page object and causing problems in updateObject().
    $query->select('a.*')
      ->from('aAccess a')
      ->innerJoin('a.Page p')
      ->where('a.privilege = ? AND p.id = ?', array($privilege, $this->id));
    $accesses = $query->execute();
    foreach ($accesses as $access)
    {
      if ($access->privilege === $privilege)
      {
        $access->delete();
      }
    }
    foreach ($ids as $id)
    {
      $access = new aAccess();
      $access->user_id = $id;
      $access->privilege = $privilege;
      $access->page_id = $this->id;
      $access->save();
    }
  }
 
  // The parent object comes back with a populated title slot.
  // The other slots are NOT populated for performance reasons
  // (is there a scenario where this would be a problem?)
  public function getParent($with = false)
  {
    if ($this->parentCache === false)
    {
      aPageTable::treeTitlesOn();
      $this->parentCache = $this->getNode()->getParent();
      aPageTable::treeTitlesOff();
    }
    return $this->parentCache;
  }

  public function delete(Doctrine_Connection $conn = null)
  {
    // TODO: must delete outstanding indexing requests here
    return aZendSearch::deleteFromDoctrineAndLucene($this, null, $conn);
  }

  public function doctrineDelete(Doctrine_Connection $conn)
  {
    return parent::delete($conn);
  }

  public function save(Doctrine_Connection $conn = null)
  {
    // We don't use saveInDoctrineAndLucene here because there are
    // too many side effects and the performance is terrible. Asynchronous 
    // indexing is the way to go
    return parent::save($conn);
  }

  public function doctrineSave(Doctrine_Connection $conn)
  {
    return parent::save($conn);
  }

  public function updateLuceneIndex()
  {
    if ($this->getAdmin())
    {
      // Never index admin pages, that goes against the spirit of 
      // keeping them completely out of navigation, they are not
      // a place for content in the normal sense, they are engines
      // for administrative purposes
      return;
    }
    $title = $this->getTitle();
    $summary = $this->getSearchSummary();
    $text = $this->getSearchText();
    $slug = $this->getSlug();
    $info = $this->getInfo();
    // Already a separate field, so don't store it twice.
    // Otherwise though the info structure is well worth it because
    // it lets us check explicit privileges
    unset($info['title']);
    aZendSearch::updateLuceneIndex($this, 
      array('text' => $text),
      $this->getCulture(),
      array(
        'title' => $title,
        'summary' => $summary,
        'slug' => $slug,
        'info' => serialize($info)));
  }

  public function getSearchSummary()
  {
    return aString::limitWords($this->getSearchText(false), sfConfig::get('app_a_search_summary_wordcount', 50), "...");
  }

  public function getSearchText($withTitle = true)
  {
    $text = "";
    $this->populateSlotCache();
    if (isset($this->slotCache[$this->culture]))
    {
      foreach ($this->slotCache[$this->culture] as $name => $area)
      {
        if (!$withTitle)
        {
          if ($name === 'title')
          {
            continue;
          }
        }
        foreach ($area as $permid => $slot)
        {
          $text .= $slot->getSearchText() . "\n";
        }
      }
    }
    return $text;
  }

  // Pages can contain slots for all cultures, but this returns the
  // culture associated with the slots that were retrieved with
  // the page in this particular case.
  public function getCulture()
  {
    return $this->culture;
  }

  // You don't call this ordinarily. It's part of the implementation of
  // fetching a page along with slots for a particualr culture.
  public function setCulture($culture)
  {
    $this->culture = $culture;
  }
  
  public function getPeersAsOptionsArray()
  {
    $peers = array();
    $parent = $this->getParent();
    if (!$parent)
    {
      return $peers;
    }
    $children = $parent->getChildren();
    foreach ($children as $child)
    {
      if ($child->id === $this->id)
      {
        continue;
      }
      $peers[$child->id] = $child->getTitle();
    }
    return $peers;
  }
  
  public function getMediaCategoriesInfo()
  {
    // Returns an array of info about media categories that are appropriate to display in the
    // media browser for the current engine page. They are sorted in alphabetical order by name,
    // with a media item count included as well
    
    // TODO: I can probably cut this down to fewer queries
    
    // Only related categories, unless this engine has none, in which case we return all categories
    $categories = Doctrine::getTable('aMediaCategory')->createQuery('mc')->innerJoin('mc.Pages p WITH p.id = ?', $this->id)->orderBy('mc.name ASC')->execute();
    if (!count($categories))
    {
      return Doctrine::getTable('aMediaCategory')->findAllAlphaInfo();
    }
    $ids = aArray::getIds($categories);
    $qresults = Doctrine_Query::create()->from('aMediaCategory mc')->select('mc.name, mc.slug, COUNT(mi.id) as mc_count')->whereIn('mc.id', $ids)->innerJoin('mc.MediaItems mi')->groupBy('mc.id')->orderBy('mc.name asc')->fetchArray();
    $info = array();
    foreach ($qresults as $qresult)
    {
      $info[] = array('name' => $qresult['name'], 'slug' => $qresult['slug'], 'count' => $qresult['mc_count']);
    }
    if (count($categories) == 1)
    {
      // Selecting amongst just one category is not interesting
      return array();
    }
    return $info;
  } 
  
  public function updateLastSlugComponent($title)
  {
    if ($this->slug === '/')
    {
      // We never update the home page slug
      return;
    }
    if ($this->getCulture() !== sfConfig::get('sf_default_culture'))
    {
      // Retitling a page in a culture other than the default does not
      // change the page slug
      return;
    }
    $component = aTools::slugify($title, false);
    $path = $this->slug;
    if (function_exists('mb_strrpos'))
    {
      $slash = mb_strrpos($path, '/');
      $newPath = mb_substr($path, 0, $slash + 1) . $component;
    }
    else
    {
      $slash = strrpos($path, '/');
      $newPath = substr($path, 0, $slash + 1) . $component;
    }
    if ($path === $newPath)
    {
      return;
    }
    $this->slug = $newPath;
    $this->save();
    Doctrine::getTable('aRedirect')->update($path, $this);
    $children = $this->getChildren();
    foreach ($children as $child)
    {
      $child->updateParentSlug($path, $newPath);
    }
  }
  
  // Update your slug based on your current parent's slug - no discussion or debate permitted.
  // Reorganize uses this. CAN be called when the parent is root, so be careful not to 
  // set a double slash as a prefix
  
  public function forceSlugFromParent()
  {
    $pslug = $this->getNode()->getParent()->slug;
    if ($pslug === '/')
    {
      $pslug = '';
    }
    if (function_exists('mb_substr'))
    {
      $slash = mb_strrpos($this->slug, '/');
      $newSlug = $pslug . mb_substr($this->slug, $slash);
    }
    else
    {
      $slash = strrpos($this->slug, '/');
      $newSlug = $pslug . substr($this->slug, $slash);      
    }
    if ($this->slug !== $newSlug)
    {
      Doctrine::getTable('aRedirect')->update($this->slug, $this);
      $this->slug = $newSlug;
      $this->save();
      $children = $this->getChildren();
      foreach ($children as $child)
      {
        $child->forceSlugFromParent();
      }
    }
  }
  
  // The parent's slug has changed (it is still the same parent). This is just an FYI - pges whose slugs
  // already diverge from the parent don't have to update their slugs too. Should never be called
  // when the parent is root
  
  public function updateParentSlug($old, $new)
  {
    if ($old === '/')
    {
      throw new sfException("You can't change the slug of the root page, why are we here?");
    }
    // Make sure this page's slug is actually prefixed by its parent's slug followed
    // by a /. If not, it has already been customized and should not get uncustomized
    // just because somebody edited the title or slug of the parent
    $slug = $this->slug;
    $old .= '/';
    if (function_exists('mb_substr'))
    {
      $stem = mb_substr($slug, 0, mb_strlen($old));
      if ($stem !== $old)
      {
        return;
      }
      $slash = mb_strrpos($slug, '/');
      $newSlug = $new . mb_substr($slug, $slash);
    }
    else
    {
      $stem = substr($slug, 0, strlen($old));
      if ($stem !== $old)
      {
        return;
      }
      $slash = strrpos($slug, '/');
      $newSlug = $new . substr($slug, $slash);
    }
    
    if ($slug !== $newSlug)
    {
      $this->slug = $newSlug;
      Doctrine::getTable('aRedirect')->update($slug, $this);
      $this->save();
      $children = $this->getChildren();
      foreach ($children as $child)
      {
        $child->updateParentSlug($slug, $newSlug);
      }
    }
  }  

  // We may need this before we're done
  // protected function str_replace($old, $new, $content)
  // {
  //   if (function_exists('mb_strpos'))
  //   {
  //     $at = 0;
  //     while (($at = mb_strpos($content, $old, $at)) !== false)
  //     {
  //       $content = mb_substr($content, 0, $at) . $new . mb_substr($content, $at + mb_strlen($old));
  //       $at = $at + strlen($old);
  //     }
  //   }
  // }
}
